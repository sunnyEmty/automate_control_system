# Построение модели пневмоцилиндра
Прежде всего, необходимо построить модель пневмоцилиндра.

Пневматические цилиндры (поршневые пневмоцилиндры) – это механические устройства , которые используют энергию сжатого газа для создания силы при возвратно-поступательном линейном движении.  Такие устроства состоят из поршня, полости (в которой размещен поршень и шток), штока. Поршень использется для преобразования энергии сжатого воздуха в энергию поступательного движения, шток – соединенный с поршнем элемент для передачи перемещения и усилия к объекту воздействия. Также рассмотрим понятия прямого и обратного хода. Прямой ход –движение поршня, при подаче давления в поршневую полость, обратный ход производится при выходе газа из поршневой полости.

В данной работе используется пневмоцилиндр с пружинным возвратом. Его характерной особенностью является применение пружины для осуществления обратного хода.

Процесс работы поршня можно описать следующим образом: при подачи сжатого газа в полость его давление воздействует на поршень, заставляя его перемещаться, до тех пор, пока он не упрется в переднюю крышку. При выходе газа из полости поршень движется в обратном направлении под действием пружины.

Построим модель пневмоцилиндра в среде SimInTech. Создадим субмодель и соберем в ней следующую схему (Рис 1.1):
<p align="center">

  <img src="https://user-images.githubusercontent.com/95709737/152410090-b15a0705-2240-455e-a05f-362172d31fbe.png">
  <div align="center">
    Рис. 1.1. Схема моделирующая работу пневмоцилиндра
  </div>

</p>

На данной схеме можно увидеть следующие блоки: ГПС - Механический элемент поступательного движения (его настройки приведены на Рис. 1.2); ГПС - Пневмомеханический преобразователь поступательного типа (Рис. 1.3); ГПС - Пневматическая полость переменного объема (изотерма или адиабата), его настройки приведены на Рис. 1.4; два блока: ГПС - Пневматический турбулентный дроссель с регулированием по произвольному параметру, на Рис. 1.5. приведены настройки левого блока, на Рис. 1.6 - правого; два блока ГПС - Давление и температура газа (настройки левого блока приведены на Рис. 1.7, правого на Рис. 1.8).

<p align="center">

  <img src="https://user-images.githubusercontent.com/95709737/152430913-9595b698-2c14-457d-bce4-8a86784e9ec9.png">
  <div align="center">
    Рис. 1.2. Параметры блока: ГПС - Механический элемент поступательного движения
  </div>

</p>

<p align="center">

  <img src="https://user-images.githubusercontent.com/95709737/152431651-b3e62cd0-acd5-44fd-aaca-1f01218dd8ab.png">
  <div align="center">
    Рис. 1.3. Настройки блока: ГПС - Пневмомеханический преобразователь поступательного типа
  </div>

</p>

<p align="center">

  <img src="https://user-images.githubusercontent.com/95709737/152431726-f15b27b4-2be1-446a-9c02-de9ae4ff5a64.png">
  <div align="center">
    Рис. 1.4. Настройки блока: Пневматическая полость переменного объема (изотерма или адиабата)
  </div>

</p>

<p align="center">

  <img src="https://user-images.githubusercontent.com/95709737/152431814-5f0dd432-5e4b-4db0-aa98-1be1f8f25cd8.png">
  <div align="center">
    Рис. 1.5. Настройки левого блока ГПС - Пневматический турбулентный дроссель с регулированием по произвольному параметру
  </div>

</p>
<p align="center">

  <img src="https://user-images.githubusercontent.com/95709737/152432046-395646ec-fae0-4c58-acd6-b738a6bb565f.png">
  <div align="center">
    Рис. 1.6. Настройки правого блока ГПС - Пневматический турбулентный дроссель с регулированием по произвольному параметру
  </div>

</p>

<p align="center">

  <img src="https://user-images.githubusercontent.com/95709737/152432694-ffef1a51-7e4f-41ce-be26-5112f4086aef.png">
  <div align="center">
    Рис. 1.7. ГПС - Давление и температура газа, настройки левого блока
  </div>

</p>

<p align="center">

  <img src="https://user-images.githubusercontent.com/95709737/152432910-167bf94a-0ea8-4b22-a0f6-01fd6ce74960.png">
  <div align="center">
    Рис. 1.8.  ГПС - Давление и температура газа, настройки правого блока
  </div>

</p>

Блок ГПС - Механический элемент поступательного движения можно редактировать войдем в него (Рис. 1.9).

<p align="center">

  <img src="https://user-images.githubusercontent.com/95709737/152433005-0b5c7567-a0e8-493b-bda3-09b4f239e330.png">
  <div align="center">
    Рис. 1.9. Редактирование блока ГПС - Механический элемент поступательного движения 
  </div>

</p>

Изменим его для вывода подробной информации о положении поршня (Рис. 10): output - текущее положение поршня, X\_max - на этом выходе единица если поршень находится в крайним верхнем положении, X\_min - на нем единица если поршень находится в крайнем нижнем положении.

<p align="center">

  <img src="https://user-images.githubusercontent.com/95709737/152433359-499f189c-c526-46eb-8f6a-bb6b34eb78b4.png">
  <div align="center">
    Рис. 1.10. Измененный блок  ГПС - Механический элемент поступательного движения
  </div>

</p>

На Рис. 1.11, 1.12 приведены настройки констант для этих выходов.

<p align="center">

  <img src="https://user-images.githubusercontent.com/95709737/152433779-0c4dedfc-cc86-4bfd-bcb3-0c86d115e0b1.png">
  <div align="center">
    Рис. 1.11. Параметры константы для выхода X_max
  </div>

</p>

<p align="center">

  <img src="https://user-images.githubusercontent.com/95709737/152434288-886c03a7-b7f0-44f4-895f-d21b3375af77.png">
  <div align="center">
    Рис 1.12. Параметры константы для выхода X_min
  </div>

</p>

Сохраним измененную схему (Рис. 1.13).
<p align="center">

  <img src="https://user-images.githubusercontent.com/95709737/152434542-26db3fe5-7f0b-49fd-b079-f5f7d390bc20.png">
  <div align="center">
    Рис. 1.13. Сохранение изменений
  </div>

</p>

Протестируем пневмоцилиндр. Построим следующую схему (она приведена на Рис. 1.14). При подаче на вход единицы поршень пневоцилиндра постепенно перемещается в крайне верхнее положение, при подаче нуля пружина двигает поршень в исходное положение. Это видно на построеннном моделью графике (Рис. 1.15).
<p align="center">

  <img src="https://user-images.githubusercontent.com/95709737/152434749-d6cb281d-0805-4d00-afcd-bccaf9652836.png">
  <div align="center">
    Рис. 1.14. Схема для тестирования субмодели
  </div>

</p>

<p align="center">

  <img src="https://user-images.githubusercontent.com/95709737/152435003-aaf331b1-f0f0-48b7-ad9c-f5cc626c7ad8.png">
  <div align="center">
    Рис. 1.15. Тестирование пневмоцилиндра
  </div>

</p>

# 2. Построение модели автомата

Исходные данные (Вариант 141).

Где - множество автоматов, - последовательность переключений автоматов, устанавливает промежутки времени, за которые пневмоцилиндры должны переключится в данные состояния, - задает время нахождения в каждом состоянии. - описывает переключения пневмоцилиндров если хотя бы один не успел перейти в данное состояние. Каждое переключение задается вектором , где – шаг на котором произошла исключительная ситуация (он соответствует своему ), – шаг, на который система перейдет в таком случае.

Процесс каждого переключения можно описать в виде автомата Мура (в нашем случае у автомата 19 состояний). Данный автомат приведен на Рис. 2.1.

Где G\_Ti - i-ое количество времени отведенное на перемещение поршня, G\_Di - i-ое количество времени отведенное на сохранение положения поршня, D - время, в течении которого поршень не подвижен, T - время в течении которого поршень подвижен.

Введем следующее обозначение (y1y2y3y4y5y6y7y8). Оно истинно когда положения пневмоцилиндров соответствуют переданным в скобкам положениям (yi равно единице для крайне верхнего положения поршня и нулю в противном случае) и ложно в противном случае. Например (10000000) соответствует высказыванию: «у первого пневмоцилиндра поршень находится в крайнем верхнем положении, у остальных – в нижнем».

![](RackMultipart20220203-4-1xj1on9_html_7998c369f5d915b3.png)

Рис. 2.1. Диаграмма Мура

# 3. Реализация автомата на языке СИ

Реализуем данный автомат. Функция init выполняет инициализацию автомата (листинг 3.1). Она принимает на вход массив структур, каждый каждая структура соответствует своему пневмоцилиндру и хранит входные, выходные значения и состояние.

Листинг 3.1 – Инициализация автомата

| void init(struct Automate\* engine, int size) {for (int i = 0; i \&lt; size; i++) {engine[i].state = STATE\_0;engine[i].ticks = time(NULL);engine[i].output = 0;engine[i].at\_bottom = 0;engine[i].at\_top = 0;engine[i].can\_change = 1;}} |
| --- |

Работу автомата можно описать следующими функциями. Функция synchro выполняет работу с несколькими пневмоцилиндрами сразу, обеспечивая подачу команд на пневмоцилиндры и возможность обнаружения исключительных ситуации (листинг 3.2).

Листинг 3.2 – Подача сигнала

| bool synchro(struct Automate\* structs, bool commands[8][18], int h) {for (int i = 0; i \&lt; h; i++) {if (!update\_state(structs + i, commands[i])) {bool success = false;switch ((structs + i)-\&gt;state) {case STATE\_2:success = resolve\_ex(structs, h, STATE\_3, commands);break;
case STATE\_3:success = resolve\_ex(structs, h, STATE\_13, commands);break;
case STATE\_5:success = resolve\_ex(structs, h, STATE\_8, commands);break;
case STATE\_6:success = resolve\_ex(structs, h, STATE\_11,commands);break;
case STATE\_7:success = resolve\_ex(structs, h, STATE\_1, commands);break;
}if (!success) {set\_err(structs, h);return false;}break;
}}return true;
} |
| --- |

В функции update\_state (листинг 3.3) отражена зависимость последующего состояния автомата от текущего (состояния).

Листинг 3.3 – Связь между состояниями

| bool update\_state(struct Automate \*engine, bool \*commands) {switch (engine-\&gt;state) {
case STATE\_0://return control\_chang\_st(engine, STATE\_0, commands[0]);return send\_com(engine, STATE\_0, commands[0]);
case STATE\_1:return send\_com(engine, STATE\_1, commands[1]);...case STATE\_15:return send\_com(engine, STATE\_15, commands[15]);
case STATE\_16:return send\_com(engine, STATE\_16, commands[16]);
case STATE\_17:return send\_com(engine, STATE\_17, commands[17]);
case STATE\_18:return send\_com(engine, STATE\_18, commands[0]);}return false;} |
| --- |

Функция send\_com фактически осуществляет задержку цилиндра в заданном положении (листинг 3.4).

Листинг 3.4 – Функция задержки

| bool send\_com(struct Automate \*engine, int state, bool com) {if (engine-\&gt;can\_change) {return control\_chang\_st(engine, state, com);} else if (A\_TIME \&gt;= G\_D[state]) { //engine-\&gt;can\_change = true;engine-\&gt;ticks = time(NULL);return control\_chang\_st(engine, state, com);}return true;} |
| --- |

Функция control\_chang\_st управляет подачей выходного сигнала и сменной состояний (листинг 3.5).

Листинг 3.5 – Функция управления

| bool control\_chang\_st(struct Automate \*engine, enum States start\_state, bool com) {int next\_state = engine-\&gt;state + 1;if (engine-\&gt;state == STATE\_18) next\_state = STATE\_1;if (engine-\&gt;state == start\_state &amp;&amp; A\_TIME \&gt; G\_T[next\_state]) // ????return false;
if ((engine-\&gt;at\_top \* com || engine-\&gt;at\_bottom \* !com)) {engine-\&gt;ticks = time(NULL);engine-\&gt;state = next\_state;ALL\_GOOD = next\_state;engine-\&gt;can\_change = false;return true;}
if (engine-\&gt;at\_bottom || engine-\&gt;at\_top) {engine-\&gt;output = com;engine-\&gt;ticks = time(NULL);return true;} else {engine-\&gt;output = com;}return true;} |
| --- |

Также присутствует функция, обрабатывающая исключительные ситуации (листинг 3.6). Она выполняется если по каким-либо причинам один или несколько пневмоцилиндров не успели сменить состояние.

Листинг 3.6 – Функция обработки исключения

| bool resolve\_ex(struct Automate \*structs, const int size, const int start\_st, bool commands[8][18]) {bool ext = true;for (int i = 0; i \&lt; size; i++) {(structs + i)-\&gt;state = start\_st;(structs + i)-\&gt;ticks = time(NULL);(structs + i)-\&gt;can\_change = true;}for (int i = 0; i \&lt; size; i++) {ext = update\_state((structs + i), commands[i]);if (!ext) return false;}
return true;} |
| --- |

# В функции set\_switch\_times производится инициализация массивов, хранящих временные промежутки (листинг 3.7).

Листинг 3.6 – Инициализация массива с временными отрезками

| bool set\_switch\_times(int a) {if (!a) return 0;const int d = 1;G\_T[0] = -1;G\_D[0] = -1;G\_T[4 + d] = G\_T[15 + d] = G\_T[16 + d] = 120;G\_T[1 + d] = G\_T[2 + d] = G\_T[3 + d] = G\_T[5 + d] = G\_T[11 + d] = G\_T[14 + d] = 56;G\_T[18] = G\_T[0 + d] = G\_T[8 + d] = G\_T[9 + d] = 60;G\_T[7 + d] = G\_T[10 + d] = G\_T[12 + d] = G\_T[13 + d] = 45;G\_T[6 + d] = 30;
G\_D[2 + d] = G\_D[3 + d] = 33;G\_D[5 + d] = G\_D[10 + d] = G\_D[11 + d] = G\_D[15 + d] = 70;G\_D[4 + d] = G\_D[8 + d] = G\_D[9 + d] = G\_D[13 + d] = G\_D[14 + d] = G\_D[16 + d] = 60;G\_D[6 + d] = G\_D[7 + d] = 45;G\_D[18] = G\_D[0 + d] = G\_D[1 + d] = G\_D[12 + d] = 78;// G\_T[2] = 1;// G\_T[4] = 2;return true;} |
| --- |

# 4. Тестирование автомата в среде SimInTech

Соберем схему для генерации кода (Рис. 4.1).

![](RackMultipart20220203-4-1xj1on9_html_2022dfb86ab5da55.png)

Рис. 4.1. Схема для генерации кода

В заголовке модуля объявляется массив структур engine, элементы которого соответствуют своим пневмоцилиндрам (Рис 4.2). Здесь также инициализируется двумерный массив com, в котором построчно заносятся команды для каждого пневмоцилиндра. Свяжем входы и выходы блока с соответствующими им полями структур в основной секции кода (Рис. 4.3).

![](RackMultipart20220203-4-1xj1on9_html_1177f2403d22f3b4.png)

Рис. 4.2. Заголовок модуля

![](RackMultipart20220203-4-1xj1on9_html_254e468064723aa6.png)

Рис. 4.3. Окно основной секции кода

Инициализация массива engine выполняется в блоке «Значения переменных по умолчанию». Также здесь выполняется инициализация массивов временных промежутков (Рис. 4.4).

![](RackMultipart20220203-4-1xj1on9_html_a5aff842495edae9.png)

Рис. 4.4. блок «Значения переменных по умолчанию»

Соберем схему для тестирования автомата (Рис. 4.5). Настроим блок DLL (Рис. 4.6).

![](RackMultipart20220203-4-1xj1on9_html_e393122398a451f1.png)

Рис. 4.5. Схема для тестирования автомата

![](RackMultipart20220203-4-1xj1on9_html_c8ff546c0a1804b.png)

Рис. 4.6. Настройка блока DLL

Протестируем работу цилиндров в «штатном режиме» (когда все пневмоцилиндры успевают сменить состояние). Ниже приведены графики положения цилиндров (Рис. 3.7) и управляющих сигналов (Рис. 3.8). Черной линеей отделен первая итерация цикла от второй.

![](RackMultipart20220203-4-1xj1on9_html_30339df50b7a7c55.png)

Рис. 4.7. Графики положений цилиндров при работе в «штатном режиме»

![](RackMultipart20220203-4-1xj1on9_html_612dec3bb81bfb8a.png)

Рис. 4.8. Графики управляющих сигналов при работе в «штатном режиме»

Теперь вызовем исключение. Пусть на первом шаге первый цилиндр не смог переключится. Эту ситуацию можно смоделировать присвоив ячейке G\_T[2] единицу (цилиндры не успеют переключиться за столь малый срок). Сделать это можно прямо в функции set\_switch\_times (листинг 3.6) - достаточно снять раскомментировать нужную строку. Получим следующие графики (Рис. 4.9 – 4.10). Как видно все цилиндры перешли в состояние ошибки, так как все поршни переместились вниз и все сигналы, подаваемые на цилиндры равны нулю.

![](RackMultipart20220203-4-1xj1on9_html_2bf04fefdce61b73.png)

Рис. 4.9. Обработка критической для работы системы ошибки

![](RackMultipart20220203-4-1xj1on9_html_8e8f39b73e6c71f3.png)

Рис. 4.10. Графики управляющих сигналов при возникновении «критической ошибки»

Теперь вызовем исключение на третьем шаге (Рис. 4.11 – 4.12). Для этого присвоим ячейке массива G\_T[4] значение равное двум (это также можно сделать раскомментировав в функции set\_switch\_times соответствующуюстроку). По графикам видно, что автомат перешел c третьего на четырнадцатый шаг.

![](RackMultipart20220203-4-1xj1on9_html_72fd8d9aeb9cffba.png)

Рис. 4.11. Положения цилиндров в момент смены шага из-за ошибки

![](RackMultipart20220203-4-1xj1on9_html_2104a1345ddcf4d6.png)

Рис. 4.12. Графики управляющих сигналов при смене шага вследствие ошибки

# ЗАКЛЮЧЕНИЕ

В результате выполнения курсовой работы были приобретены навыки построения управляющей автоматной модели по известным времяным промежуткам. Был написан автомат на языке СИ, осуществляющий управление восьмью пневмоцилиндрами.

#

# СПИСОК ИСПОЛЬЗОВАННЫХ ИНФОРМАЦИОННЫХ ИСТОЧНИКОВ

⦁ Хлебников А. А. Лекции. Автоматное программирование систем управления, РТУ МИРЭА, 2021 уч. г.

⦁ Автоматное программирование систем управления: практическая работа №9 / Под ред. А. А. Хлебникова. ― М.: Построение автоматной модели управления пневмоцилиндрами по заданной управляющей последовательности, 2021. ― 17 с.

⦁ Пневматический привод [электронный ресурс] ― URL: https://ru.wikipedia.org/wiki/Пневматический\_привод (Дата обращения: 20.04.2021)

⦁ Пневмоцилиндры ― назначение, использование и особенности конструкции [электронный ресурс] ― URL: https://kuzvesti.ru/kultura-i-iskusstvo/pnevmotsilindry-naznachenie-ispolzovanie-i-osobennosti-konstruktsii.html (Дата обращения: 20.04.2021)
